# Generated by Codex
from django.db import migrations


def dedupe_user_emails(apps, schema_editor):
    User = apps.get_model("auth", "User")
    db_alias = schema_editor.connection.alias

    buyer_username = "buyer_access"
    buyer_default_email = "buyer_access@example.com"

    buyer_user = (
        User.objects.using(db_alias)
        .filter(username=buyer_username)
        .first()
    )
    if buyer_user:
        current_email = (buyer_user.email or "").strip()
        if current_email and current_email.lower() != buyer_default_email:
            conflict_exists = (
                User.objects.using(db_alias)
                .exclude(pk=buyer_user.pk)
                .filter(email__iexact=buyer_default_email)
                .exists()
            )
            if not conflict_exists:
                buyer_user.email = buyer_default_email
                buyer_user.save(update_fields=["email"])

    rows = list(
        User.objects.using(db_alias)
        .exclude(email__isnull=True)
        .exclude(email__exact="")
        .values_list("id", "email")
    )

    duplicates: dict[str, list[tuple[int, str]]] = {}
    existing_set: set[str] = set()
    for user_id, email in rows:
        normalized = (email or "").strip().lower()
        duplicates.setdefault(normalized, []).append((user_id, email))
        if normalized:
            existing_set.add(normalized)

    for entries in duplicates.values():
        if len(entries) <= 1:
            continue

        sorted_entries = sorted(entries, key=lambda entry: entry[0])
        keeper_id, keeper_email = sorted_entries[0]
        others = sorted_entries[1:]

        keeper_normalized = (keeper_email or "").strip().lower()
        if keeper_normalized:
            existing_set.add(keeper_normalized)

        for user_id, original in others:
            user = User.objects.using(db_alias).get(pk=user_id)
            original_email = (original or "").strip()
            local_part, sep, domain_part = original_email.partition("@")
            base_local = local_part or f"user{user_id}"
            domain = domain_part if sep else "dedupe.local"
            candidate_local = f"{base_local}+dup{user_id}"
            candidate_email = f"{candidate_local}@{domain}"

            suffix = 0
            while candidate_email.strip().lower() in existing_set:
                suffix += 1
                candidate_email = f"{candidate_local}_{suffix}@{domain}"

            user.email = candidate_email
            user.save(update_fields=["email"])
            existing_set.add(candidate_email.strip().lower())


def create_ci_email_index(apps, schema_editor):
    vendor = schema_editor.connection.vendor
    if vendor == "postgresql":
        schema_editor.execute(
            "CREATE UNIQUE INDEX IF NOT EXISTS auth_user_email_ci ON auth_user (LOWER(email));"
        )
    elif vendor == "sqlite":
        schema_editor.execute(
            "CREATE UNIQUE INDEX IF NOT EXISTS auth_user_email_ci ON auth_user(email COLLATE NOCASE);"
        )
    elif vendor == "mysql":
        schema_editor.execute(
            "CREATE UNIQUE INDEX IF NOT EXISTS auth_user_email_ci ON auth_user (email);"
        )
    else:
        schema_editor.execute(
            "CREATE UNIQUE INDEX IF NOT EXISTS auth_user_email_ci ON auth_user (LOWER(email));"
        )


def drop_ci_email_index(apps, schema_editor):
    schema_editor.execute("DROP INDEX IF EXISTS auth_user_email_ci;")


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0003_studentprofile_email_verified_at_and_more"),
    ]

    operations = [
        migrations.RunPython(dedupe_user_emails, reverse_code=migrations.RunPython.noop),
        migrations.RunPython(create_ci_email_index, reverse_code=drop_ci_email_index),
    ]
